name: 'Claude Code æ“ä½œ'
description: 'åœ¨æœ¬åœ°ä»“åº“ä¸­è¿è¡Œ Claude Code'
icon: git-pull-request
color: red
outputs:
  result:
    description: 'Claude Code çš„è¾“å‡ºç»“æœ'
    value: ${{ steps.claude.outputs.result }}
  pr-url:
    description: 'åˆ›å»ºçš„æ‹‰å–è¯·æ±‚é“¾æ¥ï¼ˆå¦‚æœå¯ç”¨äº†æ‹‰å–è¯·æ±‚åˆ›å»ºï¼‰'
    value: ${{ steps.push-pr.outputs.pr-url }}
  cleanup-count:
    description: 'è¯†åˆ«å‡ºçš„éœ€æ¸…ç†åˆ†æ”¯æ•°é‡'
    value: ${{ steps.cleanup-branches.outputs.cleanup-count }}
  cleaned-count:
    description: 'å®é™…æ¸…ç†çš„åˆ†æ”¯æ•°é‡'
    value: ${{ steps.cleanup-branches.outputs.cleaned-count }}
inputs:
  prompt:
    description: 'å‘é€ç»™ Claude Code çš„æç¤ºè¯'
    required: false
  prompt-file:
    description: 'è¦ä¼ é€’ç»™ Claude Code çš„æ–‡ä»¶'
    required: false
  acknowledge-dangerously-skip-permissions-responsibility:
    description: 'å°†æ­¤å€¼è®¾ç½®ä¸º "true" è¡¨ç¤ºæ‚¨å·²é˜…è¯»å¹¶åŒæ„è¿è¡Œ `claude code --dangerously-skip-permissions` æ—¶æ˜¾ç¤ºçš„å…è´£å£°æ˜'
    required: true
  verbose:
    description: 'å¯ç”¨ Claude Code çš„è¯¦ç»†è¾“å‡º'
    required: false
  create-pr:
    description: 'ä¸º Claude çš„å˜æ›´åˆ›å»ºæ‹‰å–è¯·æ±‚'
    required: false
    default: 'true'
  base-branch:
    description: 'åˆ›å»ºæ‹‰å–è¯·æ±‚çš„ç›®æ ‡åˆ†æ”¯'
    required: false
    default: 'main'
  cleanup-branches:
    description: 'å¯ç”¨è‡ªåŠ¨æ¸…ç†æ—§çš„ Claude Code åˆ†æ”¯'
    required: false
    default: 'true'
  cleanup-pattern:
    description: 'åŒ¹é…éœ€è¦æ¸…ç†çš„åˆ†æ”¯æ¨¡å¼ï¼ˆæ”¯æŒæ­£åˆ™è¡¨è¾¾å¼ï¼‰'
    required: false
    default: '^claude-code-changes-.*'
  cleanup-keep-days:
    description: 'ä¿ç•™ N å¤©å†…åˆ›å»ºçš„åˆ†æ”¯ï¼ˆ0 = æ— æ—¶é—´é™åˆ¶ï¼‰'
    required: false
    default: '7'
  cleanup-merged-only:
    description: 'ä»…æ¸…ç†å·²åˆå¹¶æˆ–å…³é—­çš„åˆ†æ”¯'
    required: false
    default: 'true'
  cleanup-dry-run:
    description: 'æ˜¾ç¤ºå°†è¢«æ¸…ç†çš„å†…å®¹ä½†ä¸å®é™…åˆ é™¤'
    required: false
    default: 'false'
    
runs:
  using: 'composite'
  steps:
    - name: Check acknowledgement
      shell: bash
      run: |
        if [ "${{ inputs.acknowledge-dangerously-skip-permissions-responsibility }}" != "true" ]; then
          echo "é”™è¯¯ï¼šæ‚¨å¿…é¡»å°† acknowledge-dangerously-skip-permissions-responsibility è®¾ç½®ä¸º true æ‰èƒ½ä½¿ç”¨æ­¤æ“ä½œã€‚"
          echo "è¿™è¡¨ç¤ºæ‚¨å·²é˜…è¯»å¹¶åŒæ„è¿è¡Œ 'claude code --dangerously-skip-permissions' æ—¶æ˜¾ç¤ºçš„å…è´£å£°æ˜ã€‚"
          exit 1
        fi
        echo "ç¡®è®¤å·²é˜…è¯»å£°æ˜ã€‚"
    
    - name: Validate prompt inputs
      shell: bash
      run: |
        if [ -z "${{ inputs.prompt }}" ] && [ -z "${{ inputs.prompt-file }}" ]; then
          echo "é”™è¯¯ï¼šæ‚¨å¿…é¡»æä¾› 'prompt' æˆ– 'prompt-file' è¾“å…¥ã€‚"
          exit 1
        fi
        echo "æç¤ºè¯è¾“å…¥éªŒè¯é€šè¿‡ã€‚"

    - name: Setup Claude Config for Docker
      shell: bash
      run: |
        mkdir -p ${GITHUB_ACTION_PATH}/claude-code/.claude
        
        # Start with base config template
        cp ${GITHUB_ACTION_PATH}/config_template.json ${GITHUB_ACTION_PATH}/claude-code/.claude/.claude.json
        
        # Replace API key
        sed -i 's/CLAUDE_API_KEY/${{ env.ANTHROPIC_API_KEY }}/' ${GITHUB_ACTION_PATH}/claude-code/.claude/.claude.json
        
        # Add base URL if provided via environment variable
        if [ -n "${{ env.ANTHROPIC_BASE_URL }}" ]; then
          echo "é…ç½®è‡ªå®šä¹‰ Anthropic API ç«¯ç‚¹: ${{ env.ANTHROPIC_BASE_URL }}"
          # Add baseUrl to the config JSON
          sed -i "2i\\  \"baseUrl\": \"${{ env.ANTHROPIC_BASE_URL }}\"," ${GITHUB_ACTION_PATH}/claude-code/.claude/.claude.json
        else
          echo "ä½¿ç”¨é»˜è®¤ Anthropic API ç«¯ç‚¹"
        fi
        
        chmod 666 ${GITHUB_ACTION_PATH}/claude-code/.claude/.claude.json
        echo "Docker æŒ‚è½½çš„ Claude é…ç½®å·²åˆ›å»º"
        
        # Debug: Show config (without API key)
        echo "é…ç½®æ–‡ä»¶å†…å®¹é¢„è§ˆ:"
        sed 's/"[^"]*API[^"]*"/"[REDACTED]"/' ${GITHUB_ACTION_PATH}/claude-code/.claude/.claude.json | head -10

    - name: Start Claude Docker container
      shell: bash
      run: |
        echo "æ­£åœ¨å¯åŠ¨ Claude Docker å®¹å™¨..."
        
        # Get the UID and GID of the current user on the host (the runner)
        HOST_UID=$(id -u)
        HOST_GID=$(id -g)
        echo "ä¸»æœºè¿è¡Œå™¨ UID:GID = $HOST_UID:$HOST_GID"
        
        # Start the container with the host's UID and GID
        docker run -dit --rm \
          --name claude-code-container \
          --cap-add=NET_ADMIN --cap-add=NET_RAW \
          -e NODE_OPTIONS="--max-old-space-size=4096" \
          -e CLAUDE_CONFIG_DIR="/home/node/.claude" \
          -e POWERLEVEL9K_DISABLE_GITSTATUS="true" \
          -v claude-code-bashhistory:/commandhistory \
          -v "${GITHUB_ACTION_PATH}/claude-code/.claude:/home/node/.claude" \
          -v "$(pwd)":/workspace:delegated \
          -w /workspace \
          --user $HOST_UID:$HOST_GID \
          ghcr.io/joesarre/claude-code-action/claude-code-sandbox:latest
        
        # Run the init-firewall script inside the container as root
        # docker exec -u root claude-code-container /usr/local/bin/init-firewall.sh
        
        # Change ownership of directories that were originally owned by node user
        # This ensures the container user (with host UID/GID) can access these directories
        docker exec -u root claude-code-container bash -c "
          chown -R $HOST_UID:$HOST_GID /usr/local/share/npm-global /usr/local/share
          chown -R $HOST_UID:$HOST_GID /commandhistory
          chown -R $HOST_UID:$HOST_GID /home/node/.claude
        "
        
        # Check that /home/node/.claude/.claude.json exists and is accessible
        docker exec -u $HOST_UID:$HOST_GID claude-code-container test -f /home/node/.claude/.claude.json

    - name: Run Claude in Docker container
      id: claude
      shell: bash
      run: |
        HOST_UID=$(id -u)
        HOST_GID=$(id -g)
        echo "ä¸»æœºè¿è¡Œå™¨ UID:GID = $HOST_UID:$HOST_GID"

        (
          set +e  # allow script to continue on errors
          set +x  # debug
          
          EXIT_CODE=0
          
          # Prepare environment variables for Docker
          DOCKER_ENV_VARS="-e HOME=/home/node -e ANTHROPIC_API_KEY=$ANTHROPIC_API_KEY"
          if [ -n "${{ env.ANTHROPIC_BASE_URL }}" ]; then
            DOCKER_ENV_VARS="$DOCKER_ENV_VARS -e ANTHROPIC_BASE_URL=${{ env.ANTHROPIC_BASE_URL }}"
          fi
          
          if [ "${{ inputs.prompt }}" != "" ] && [ "${{ inputs.prompt-file }}" != "" ]; then
            echo "åŒæ—¶ä½¿ç”¨æç¤ºè¯å’Œæ–‡ä»¶è¿è¡Œ Claude"
            echo "æç¤ºè¯å‚æ•°ï¼š${{ inputs.prompt }}"
            echo "æç¤ºè¯æ–‡ä»¶ï¼š${{ inputs.prompt-file }}"
            if [ "${{ inputs.verbose }}" != "true" ]; then
              timeout 30m docker exec -i -u $HOST_UID:$HOST_GID $DOCKER_ENV_VARS claude-code-container claude -p --dangerously-skip-permissions '${{ inputs.prompt }}' < "${{ inputs.prompt-file }}" > ~/claude-output.txt
              EXIT_CODE=$?
            else
              timeout 30m docker exec -i -u $HOST_UID:$HOST_GID $DOCKER_ENV_VARS claude-code-container claude -p --dangerously-skip-permissions '${{ inputs.prompt }}' --verbose --output-format stream-json < "${{ inputs.prompt-file }}" | ${GITHUB_ACTION_PATH}/parse_claude_output.sh > ~/claude-output.txt
              EXIT_CODE=$?
            fi
          elif [ "${{ inputs.prompt }}" != "" ]; then
            echo "ä»…ä½¿ç”¨æç¤ºè¯å‚æ•°è¿è¡Œ Claude"
            echo "æç¤ºè¯ï¼š${{ inputs.prompt }}"
            if [ "${{ inputs.verbose }}" != "true" ]; then
              timeout 30m docker exec -i -u $HOST_UID:$HOST_GID $DOCKER_ENV_VARS claude-code-container claude -p --dangerously-skip-permissions '${{ inputs.prompt }}' > ~/claude-output.txt 2>&1
              EXIT_CODE=$?
            else
              timeout 30m docker exec -i -u $HOST_UID:$HOST_GID $DOCKER_ENV_VARS claude-code-container claude -p --dangerously-skip-permissions '${{ inputs.prompt }}' --verbose --output-format stream-json | ${GITHUB_ACTION_PATH}/parse_claude_output.sh > ~/claude-output.txt 2>&1
              EXIT_CODE=$?
            fi
          elif [ "${{ inputs.prompt-file }}" != "" ]; then
            echo "ä»…ä½¿ç”¨æç¤ºè¯æ–‡ä»¶è¿è¡Œ Claude"
            echo "æç¤ºè¯æ–‡ä»¶ï¼š${{ inputs.prompt-file }}"
            if [ "${{ inputs.verbose }}" != "true" ]; then
              timeout 30m docker exec -i -u $HOST_UID:$HOST_GID $DOCKER_ENV_VARS claude-code-container claude -p --dangerously-skip-permissions < "${{ inputs.prompt-file }}" > ~/claude-output.txt 2>&1
              EXIT_CODE=$?
            else
              timeout 30m docker exec -i -u $HOST_UID:$HOST_GID $DOCKER_ENV_VARS claude-code-container claude -p --dangerously-skip-permissions --verbose --output-format stream-json < "${{ inputs.prompt-file }}" | ${GITHUB_ACTION_PATH}/parse_claude_output.sh > ~/claude-output.txt 2>&1
              EXIT_CODE=$?
            fi
          fi

          echo "Claude è¾“å‡ºï¼š"
          cat ~/claude-output.txt

          # Set the output variable. Use a random string for the EOF marker so that EOF in the claude output (which can happen if claude does any bash work) doesn't confuse github
          echo "result<<EOF3c959e1250034ce183a56fcb738119a5" >> $GITHUB_OUTPUT
          cat ~/claude-output.txt >> $GITHUB_OUTPUT
          echo "EOF3c959e1250034ce183a56fcb738119a5" >> $GITHUB_OUTPUT

          exit $EXIT_CODE
        )

    - name: Detect git changes
      id: git-changes
      shell: bash
      run: |
        if [ "${{ inputs.create-pr }}" == "true" ]; then
          echo "æ­£åœ¨æ£€æŸ¥ git å˜æ›´..."
          
          # Configure git if not already configured
          git config --global --add safe.directory /workspace || true
          git config --global user.name "Claude Code Action" || true
          git config --global user.email "action@users.noreply.github.com" || true
          
          # Check if there are any changes
          if [ -n "$(git status --porcelain)" ]; then
            echo "changes-detected=true" >> $GITHUB_OUTPUT
            echo "æ£€æµ‹åˆ°å˜æ›´ï¼š"
            git status --short
          else
            echo "changes-detected=false" >> $GITHUB_OUTPUT
            echo "æœªæ£€æµ‹åˆ°å˜æ›´"
          fi
        else
          echo "æœªå¯ç”¨æ‹‰å–è¯·æ±‚åˆ›å»ºï¼Œè·³è¿‡å˜æ›´æ£€æµ‹"
          echo "changes-detected=false" >> $GITHUB_OUTPUT
        fi

    - name: Cleanup old branches
      id: cleanup-branches
      if: inputs.cleanup-branches == 'true'
      shell: bash
      run: |
        echo "ğŸ§¹ å¼€å§‹åˆ†æ”¯æ¸…ç†è¿›ç¨‹..."
        
        # Configuration
        CLEANUP_PATTERN="${{ inputs.cleanup-pattern }}"
        KEEP_DAYS="${{ inputs.cleanup-keep-days }}"
        MERGED_ONLY="${{ inputs.cleanup-merged-only }}"
        DRY_RUN="${{ inputs.cleanup-dry-run }}"
        
        echo "ğŸ“‹ æ¸…ç†é…ç½®ï¼š"
        echo "  æ¨¡å¼ï¼š $CLEANUP_PATTERN"
        echo "  ä¿ç•™å¤©æ•°ï¼š $KEEP_DAYS"
        echo "  ä»…å·²åˆå¹¶ï¼š $MERGED_ONLY"
        echo "  å¹²è¿è¡Œï¼š $DRY_RUN"
        echo ""
        
        # Fetch latest branch information
        git fetch origin --prune
        
        # Get current branch to avoid deleting it
        CURRENT_BRANCH=$(git branch --show-current)
        echo "ğŸ”’ å½“å‰åˆ†æ”¯ï¼ˆå—ä¿æŠ¤ï¼‰ï¼š $CURRENT_BRANCH"
        
        # Protected branches that should never be deleted
        PROTECTED_BRANCHES="main master develop staging production release"
        echo "ğŸ”’ å—ä¿æŠ¤çš„åˆ†æ”¯ï¼š $PROTECTED_BRANCHES"
        echo ""
        
        # Find candidate branches for cleanup
        echo "ğŸ” æ‰«ææ¸…ç†å€™é€‰åˆ†æ”¯..."
        CLEANUP_CANDIDATES=()
        CLEANUP_SUMMARY=""
        
        # Get all remote branches that match the pattern
        for branch in $(git branch -r --format='%(refname:short)' | grep -E "$CLEANUP_PATTERN" | sed 's/origin\///'); do
          # Skip if it's the current branch
          if [ "$branch" = "$CURRENT_BRANCH" ]; then
            echo "â­ï¸  è·³è¿‡å½“å‰åˆ†æ”¯ï¼š $branch"
            continue
          fi
          
          # Skip if it's a protected branch
          if echo "$PROTECTED_BRANCHES" | grep -wq "$branch"; then
            echo "â­ï¸  è·³è¿‡å—ä¿æŠ¤åˆ†æ”¯ï¼š $branch"
            continue
          fi
          
          echo "ğŸ“Š åˆ†æåˆ†æ”¯ï¼š $branch"
          
          # Check branch age if KEEP_DAYS > 0
          if [ "$KEEP_DAYS" -gt 0 ]; then
            # Get the creation date of the branch
            BRANCH_DATE=$(git log -1 --format="%ct" "origin/$branch" 2>/dev/null || echo "0")
            CURRENT_DATE=$(date +%s)
            AGE_DAYS=$(( (CURRENT_DATE - BRANCH_DATE) / 86400 ))
            
            if [ "$AGE_DAYS" -lt "$KEEP_DAYS" ]; then
              echo "   â° å¤ªæ–°ï¼ˆ$AGE_DAYS å¤©å‰ï¼Œä¿ç•™ < $KEEP_DAYS å¤©çš„åˆ†æ”¯ï¼‰"
              continue
            else
              echo "   â° å¹´é¾„ï¼š $AGE_DAYS å¤©ï¼ˆç¬¦åˆæ¸…ç†æ¡ä»¶ï¼‰"
            fi
          fi
          
          # Check PR status if MERGED_ONLY is true
          if [ "$MERGED_ONLY" = "true" ]; then
            # Check if there's a PR for this branch and its status
            PR_STATE=$(gh pr list --head "$branch" --json state --jq '.[0].state' 2>/dev/null || echo "")
            
            if [ -z "$PR_STATE" ]; then
              echo "   ğŸ” æœªæ‰¾åˆ°æ­¤åˆ†æ”¯çš„æ‹‰å–è¯·æ±‚"
              # Allow deletion of branches without PRs if they're old enough
            elif [ "$PR_STATE" = "MERGED" ]; then
              echo "   âœ… æ‹‰å–è¯·æ±‚å·²åˆå¹¶ï¼ˆå¯å®‰å…¨åˆ é™¤ï¼‰"
            elif [ "$PR_STATE" = "CLOSED" ]; then
              echo "   âŒ æ‹‰å–è¯·æ±‚å·²å…³é—­ï¼ˆå¯å®‰å…¨åˆ é™¤ï¼‰"
            elif [ "$PR_STATE" = "OPEN" ]; then
              echo "   ğŸ”„ æ‹‰å–è¯·æ±‚ä»åœ¨å¼€æ”¾ä¸­ï¼ˆè·³è¿‡ï¼‰"
              continue
            else
              echo "   â“ æœªçŸ¥æ‹‰å–è¯·æ±‚çŠ¶æ€ï¼š $PR_STATEï¼ˆè·³è¿‡ï¼‰"
              continue
            fi
          fi
          
          # Add to cleanup candidates
          CLEANUP_CANDIDATES+=("$branch")
          CLEANUP_SUMMARY="$CLEANUP_SUMMARY\n- $branch"
          echo "   âœ“ å·²æ·»åŠ åˆ°æ¸…ç†åˆ—è¡¨"
        done
        
        echo ""
        echo "ğŸ“ æ¸…ç†æ‘˜è¦ï¼š"
        if [ ${#CLEANUP_CANDIDATES[@]} -eq 0 ]; then
          echo "   æœªæ‰¾åˆ°éœ€è¦æ¸…ç†çš„åˆ†æ”¯"
          echo "cleanup-count=0" >> $GITHUB_OUTPUT
        else
          echo "   æ‰¾åˆ° ${#CLEANUP_CANDIDATES[@]} ä¸ªéœ€è¦æ¸…ç†çš„åˆ†æ”¯ï¼š"
          printf "$CLEANUP_SUMMARY\n"
          echo "cleanup-count=${#CLEANUP_CANDIDATES[@]}" >> $GITHUB_OUTPUT
          
          # Execute cleanup
          if [ "$DRY_RUN" = "true" ]; then
            echo ""
            echo "ğŸ” å¹²è¿è¡Œæ¨¡å¼ - ä¸ä¼šåˆ é™¤ä»»ä½•åˆ†æ”¯"
            echo "cleanup-executed=false" >> $GITHUB_OUTPUT
          else
            echo ""
            echo "ğŸ—‘ï¸  æ­£åœ¨æ‰§è¡Œæ¸…ç†..."
            CLEANED_COUNT=0
            for branch in "${CLEANUP_CANDIDATES[@]}"; do
              echo "   æ­£åœ¨åˆ é™¤åˆ†æ”¯ï¼š $branch"
              if git push origin --delete "$branch" 2>/dev/null; then
                echo "   âœ… æˆåŠŸåˆ é™¤ï¼š $branch"
                ((CLEANED_COUNT++))
              else
                echo "   âŒ åˆ é™¤å¤±è´¥ï¼š $branch"
              fi
            done
            echo "cleanup-executed=true" >> $GITHUB_OUTPUT
            echo "cleaned-count=$CLEANED_COUNT" >> $GITHUB_OUTPUT
            echo ""
            echo "ğŸ‰ æ¸…ç†å®Œæˆï¼åˆ é™¤äº† ${#CLEANUP_CANDIDATES[@]} ä¸ªåˆ†æ”¯ä¸­çš„ $CLEANED_COUNT ä¸ª"
          fi
        fi

    - name: Create branch and commit changes
      id: commit-changes
      if: steps.git-changes.outputs.changes-detected == 'true'
      shell: bash
      run: |
        echo "æ­£åœ¨åˆ›å»ºåˆ†æ”¯å¹¶æäº¤å˜æ›´..."
        
        # Auto-generate branch name with timestamp
        TIMESTAMP=$(date +%Y%m%d-%H%M%S)
        BRANCH_NAME="claude-code-changes-${TIMESTAMP}"
        
        echo "åˆ†æ”¯åç§°ï¼š $BRANCH_NAME"
        echo "branch-name=$BRANCH_NAME" >> $GITHUB_OUTPUT
        
        # Create and switch to new branch
        git checkout -b "$BRANCH_NAME"
        
        # Stage all changes
        git add .
        
        # Auto-generate commit message based on prompt
        PROMPT_SUMMARY="${{ inputs.prompt }}"
        if [ -z "$PROMPT_SUMMARY" ]; then
          PROMPT_SUMMARY="ä»£ç ä¼˜åŒ–å’Œæ”¹è¿›"
        fi
        
        COMMIT_MESSAGE="ğŸ¤– Claude Code: ${PROMPT_SUMMARY}

        é€šè¿‡ Claude Code è‡ªåŠ¨åŒ–å¤„ç†ï¼ŒåŸºäºæç¤ºè¯è¿›è¡Œçš„æ™ºèƒ½ä»£ç å˜æ›´ã€‚

        ğŸ”§ Generated with [Claude Code](https://claude.ai/code)

        Co-Authored-By: Claude <noreply@anthropic.com>"
        
        git commit -m "$COMMIT_MESSAGE"
        echo "å˜æ›´å·²æˆåŠŸæäº¤"

    - name: Analyze changes with Claude
      id: analyze-changes
      if: steps.commit-changes.outputs.branch-name != ''
      shell: bash
      run: |
        echo "ğŸ” æ­£åœ¨æ”¶é›†ä»£ç å˜æ›´ä¿¡æ¯ç”¨äºæ™ºèƒ½åˆ†æ..."
        
        # Collect git diff and statistics
        echo "æ”¶é›†å˜æ›´ç»Ÿè®¡..."
        STATS=$(git diff --stat HEAD~1 HEAD 2>/dev/null || git diff --stat ${{ inputs.base-branch }} HEAD 2>/dev/null || echo "æ— æ³•ç”Ÿæˆç»Ÿè®¡ä¿¡æ¯")
        
        echo "æ”¶é›†è¯¦ç»†å·®å¼‚..."
        DIFF=$(git diff HEAD~1 HEAD 2>/dev/null || git diff ${{ inputs.base-branch }} HEAD 2>/dev/null || echo "æ— æ³•ç”Ÿæˆå·®å¼‚ä¿¡æ¯")
        
        # Limit diff size to prevent API overload (keep first 8000 chars)
        if [ ${#DIFF} -gt 8000 ]; then
          DIFF="${DIFF:0:8000}... [å·®å¼‚å†…å®¹è¿‡é•¿å·²æˆªæ–­]"
        fi
        
        echo "æ”¶é›†æ–‡ä»¶åˆ—è¡¨..."
        CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || git diff --name-only ${{ inputs.base-branch }} HEAD 2>/dev/null || echo "æ— æ³•è·å–æ–‡ä»¶åˆ—è¡¨")
        
        # Save to files for next step
        echo "$STATS" > /tmp/git-stats.txt
        echo "$DIFF" > /tmp/git-diff.txt  
        echo "$CHANGED_FILES" > /tmp/changed-files.txt
        
        echo "âœ… å˜æ›´ä¿¡æ¯æ”¶é›†å®Œæˆ"

    - name: Generate PR content with Claude
      id: generate-pr
      if: steps.commit-changes.outputs.branch-name != ''
      shell: bash
      run: |
        echo "ğŸ¤– æ­£åœ¨ä½¿ç”¨ Claude æ™ºèƒ½ç”Ÿæˆ PR å†…å®¹..."
        
        # Read collected information
        STATS=$(cat /tmp/git-stats.txt)
        DIFF=$(cat /tmp/git-diff.txt)
        CHANGED_FILES=$(cat /tmp/changed-files.txt)
        USER_PROMPT="${{ inputs.prompt }}"
        
        # Create analysis prompt for Claude
        ANALYSIS_PROMPT="è¯·ä½œä¸ºä¸€ä¸ªä¸“ä¸šçš„ä»£ç å®¡æŸ¥ä¸“å®¶ï¼Œåˆ†æä»¥ä¸‹ä»£ç å˜æ›´å¹¶ç”Ÿæˆä¸“ä¸šçš„ Pull Request æ ‡é¢˜å’Œæè¿°ã€‚

        åŸå§‹ç”¨æˆ·è¯·æ±‚ï¼š
        ${USER_PROMPT}

        å˜æ›´ç»Ÿè®¡ï¼š
        ${STATS}

        å˜æ›´çš„æ–‡ä»¶ï¼š
        ${CHANGED_FILES}

        ä»£ç å·®å¼‚ï¼š
        ${DIFF}

        è¯·æŒ‰ç…§ä»¥ä¸‹æ ¼å¼è¾“å‡ºï¼š

        PR_TITLE: [ç®€æ´ä¸“ä¸šçš„PRæ ‡é¢˜ï¼Œä¸è¶…è¿‡60å­—ç¬¦ï¼Œä½“ç°ä¸»è¦å˜æ›´]
        PR_BODY: [è¯¦ç»†çš„PRæè¿°ï¼ŒåŒ…æ‹¬ï¼š
        1. å˜æ›´æ¦‚è¿°ï¼ˆ2-3å¥è¯è¯´æ˜åšäº†ä»€ä¹ˆï¼‰
        2. ä¸»è¦æ”¹åŠ¨ç‚¹ï¼ˆåˆ—å‡º3-5ä¸ªå…³é”®å˜æ›´ï¼‰
        3. å½±å“èŒƒå›´ï¼ˆè¯´æ˜å¯èƒ½å½±å“çš„åŠŸèƒ½æˆ–æ¨¡å—ï¼‰
        4. æµ‹è¯•å»ºè®®ï¼ˆå¦‚æœé€‚ç”¨ï¼‰
        è¯·ç”¨ä¸“ä¸šä½†æ˜“æ‡‚çš„ä¸­æ–‡æè¿°]

        æ³¨æ„ï¼š
        - æ ‡é¢˜è¦ç®€æ´æœ‰åŠ›ï¼Œä½“ç°æ ¸å¿ƒæ”¹åŠ¨
        - æè¿°è¦ä¸“ä¸šè¯¦ç»†ï¼Œä½†é¿å…è¿‡äºæŠ€æœ¯åŒ–
        - é‡ç‚¹å…³æ³¨ä¸šåŠ¡ä»·å€¼å’Œç”¨æˆ·å½±å“
        - å¦‚æœæ˜¯é‡æ„ï¼Œè¯´æ˜æ”¹è¿›çš„æ–¹é¢
        - å¦‚æœæ˜¯æ–°åŠŸèƒ½ï¼Œè¯´æ˜åŠŸèƒ½ä»·å€¼"

        # Create temporary file for analysis
        echo "$ANALYSIS_PROMPT" > /tmp/claude-analysis-prompt.txt
        
        echo "ğŸ“¡ æ­£åœ¨è°ƒç”¨ Claude è¿›è¡Œæ™ºèƒ½åˆ†æ..."
        
        # Prepare environment variables for Docker (in analysis step)
        ANALYSIS_DOCKER_ENV="-e ANTHROPIC_API_KEY=$ANTHROPIC_API_KEY"
        if [ -n "${{ env.ANTHROPIC_BASE_URL }}" ]; then
          ANALYSIS_DOCKER_ENV="$ANALYSIS_DOCKER_ENV -e ANTHROPIC_BASE_URL=${{ env.ANTHROPIC_BASE_URL }}"
        fi
        
        # Call Claude to analyze changes with timeout
        timeout 300s docker exec -i $ANALYSIS_DOCKER_ENV claude-code-container claude -p --dangerously-skip-permissions "$(cat /tmp/claude-analysis-prompt.txt)" > /tmp/claude-analysis-result.txt 2>&1
        CLAUDE_EXIT_CODE=$?
        
        if [ $CLAUDE_EXIT_CODE -eq 0 ]; then
          echo "âœ… Claude æ™ºèƒ½åˆ†æå®Œæˆ"
          
          # Check if we got a proper response
          if grep -q "PR_TITLE:" /tmp/claude-analysis-result.txt && grep -q "PR_BODY:" /tmp/claude-analysis-result.txt; then
            echo "ğŸ¯ è§£ææˆåŠŸï¼Œæ‰¾åˆ°æ ‡å‡†æ ¼å¼è¾“å‡º"
            echo "--- Claude åˆ†æç»“æœé¢„è§ˆ ---"
            head -10 /tmp/claude-analysis-result.txt
            echo "--- é¢„è§ˆç»“æŸ ---"
          else
            echo "âš ï¸ Claude è¾“å‡ºæ ¼å¼ä¸æ ‡å‡†ï¼Œä½¿ç”¨å¤‡ç”¨è§£æ"
            # Try to use the whole output as PR body
            echo "PR_TITLE: ğŸ¤– Claude Code: ${USER_PROMPT}" > /tmp/claude-analysis-fallback.txt
            echo "PR_BODY: " >> /tmp/claude-analysis-fallback.txt
            cat /tmp/claude-analysis-result.txt >> /tmp/claude-analysis-fallback.txt
            mv /tmp/claude-analysis-fallback.txt /tmp/claude-analysis-result.txt
          fi
        else
          echo "âš ï¸ Claude åˆ†æå¤±è´¥ (é€€å‡ºç : $CLAUDE_EXIT_CODE)ï¼Œä½¿ç”¨å¤‡ç”¨æ–¹æ¡ˆ"
          echo "é”™è¯¯ä¿¡æ¯ï¼š"
          tail -5 /tmp/claude-analysis-result.txt 2>/dev/null || echo "æ— æ³•è¯»å–é”™è¯¯ä¿¡æ¯"
          
          # Fallback to simple generation
          echo "PR_TITLE: ğŸ¤– Claude Code: ${USER_PROMPT}" > /tmp/claude-analysis-result.txt
          echo "PR_BODY: **å˜æ›´è¯´æ˜:** ${USER_PROMPT}" >> /tmp/claude-analysis-result.txt
          echo "" >> /tmp/claude-analysis-result.txt
          echo "é€šè¿‡ Claude Code åŸºäºç”¨æˆ·æç¤ºè¯è¿›è¡Œçš„æ™ºèƒ½ä»£ç å˜æ›´ã€‚" >> /tmp/claude-analysis-result.txt
          echo "" >> /tmp/claude-analysis-result.txt
          echo "âš ï¸ æ³¨æ„ï¼šç”±äº Claude åˆ†ææœåŠ¡ä¸´æ—¶ä¸å¯ç”¨ï¼Œæ­¤æè¿°ä¸ºè‡ªåŠ¨ç”Ÿæˆçš„å¤‡ç”¨å†…å®¹ã€‚" >> /tmp/claude-analysis-result.txt
        fi

    - name: Push branch and create Pull Request
      id: push-pr
      if: steps.commit-changes.outputs.branch-name != ''
      shell: bash
      run: |
        echo "æ­£åœ¨æ¨é€åˆ†æ”¯å¹¶åˆ›å»ºæ‹‰å–è¯·æ±‚..."
        
        BRANCH_NAME="${{ steps.commit-changes.outputs.branch-name }}"
        
        # Push the branch to remote
        echo "æ­£åœ¨æ¨é€åˆ†æ”¯ï¼š $BRANCH_NAME"
        git push origin "$BRANCH_NAME"
        
        # Create Pull Request using GitHub CLI
        echo "æ­£åœ¨åˆ›å»ºæ‹‰å–è¯·æ±‚..."
        
        # Parse Claude analysis result
        if [ -f "/tmp/claude-analysis-result.txt" ]; then
          echo "ğŸ“‹ è§£æ Claude æ™ºèƒ½åˆ†æç»“æœ..."
          
          # Extract PR title and body from Claude's analysis
          PR_TITLE=$(grep "^PR_TITLE:" /tmp/claude-analysis-result.txt | sed 's/^PR_TITLE: *//' | head -1)
          
          # Extract PR body - everything after "PR_BODY:" until end of file
          PR_BODY_RAW=$(sed -n '/^PR_BODY:/,$p' /tmp/claude-analysis-result.txt | sed '1s/^PR_BODY: *//' | sed '/^$/N;/^\n$/d')
          
          # Fallback if parsing fails
          if [ -z "$PR_TITLE" ]; then
            USER_PROMPT="${{ inputs.prompt }}"
            PR_TITLE="ğŸ¤– Claude Code: ${USER_PROMPT}"
            echo "âš ï¸ æ— æ³•è§£ææ ‡é¢˜ï¼Œä½¿ç”¨å¤‡ç”¨æ–¹æ¡ˆ"
          fi
          
          if [ -z "$PR_BODY_RAW" ]; then
            USER_PROMPT="${{ inputs.prompt }}"
            PR_BODY_RAW="**å˜æ›´è¯´æ˜:** ${USER_PROMPT}

            é€šè¿‡ Claude Code åŸºäºç”¨æˆ·æç¤ºè¯è¿›è¡Œçš„æ™ºèƒ½ä»£ç å˜æ›´ã€‚"
            echo "âš ï¸ æ— æ³•è§£ææè¿°ï¼Œä½¿ç”¨å¤‡ç”¨æ–¹æ¡ˆ"
          fi
          
          echo "ğŸ“ ä½¿ç”¨ Claude æ™ºèƒ½ç”Ÿæˆçš„å†…å®¹ï¼š"
          echo "æ ‡é¢˜: $PR_TITLE"
          echo "æè¿°é¢„è§ˆ: $(echo "$PR_BODY_RAW" | head -3 | tr '\n' ' ')..."
          
        else
          echo "âš ï¸ æœªæ‰¾åˆ° Claude åˆ†æç»“æœï¼Œä½¿ç”¨å¤‡ç”¨æ–¹æ¡ˆ"
          USER_PROMPT="${{ inputs.prompt }}"
          PR_TITLE="ğŸ¤– Claude Code: ${USER_PROMPT}"
          PR_BODY_RAW="**å˜æ›´è¯´æ˜:** ${USER_PROMPT}

          é€šè¿‡ Claude Code åŸºäºç”¨æˆ·æç¤ºè¯è¿›è¡Œçš„æ™ºèƒ½ä»£ç å˜æ›´ã€‚"
        fi
        
        # Construct final PR body with metadata
        PR_BODY="${PR_BODY_RAW}

        ---
        ğŸ¤– æ­¤æ‹‰å–è¯·æ±‚ç”± Claude Code Action æ™ºèƒ½ç”Ÿæˆã€‚

        **å˜æ›´æ¥æº:** Claude Code  
        **ç›®æ ‡åˆ†æ”¯:** ${{ inputs.base-branch }}  
        **æºåˆ†æ”¯:** $BRANCH_NAME  

        ğŸ”§ Generated with [Claude Code](https://claude.ai/code)"
        
        # Create the PR and capture the URL
        PR_URL=$(gh pr create \
          --title "$PR_TITLE" \
          --body "$PR_BODY" \
          --base "${{ inputs.base-branch }}" \
          --head "$BRANCH_NAME")
        
        echo "æ‹‰å–è¯·æ±‚åˆ›å»ºæˆåŠŸï¼š $PR_URL"
        echo "pr-url=$PR_URL" >> $GITHUB_OUTPUT
        
        # Add PR URL to the step summary
        echo "## ğŸ‰ æ‹‰å–è¯·æ±‚å·²åˆ›å»º" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**æ‹‰å–è¯·æ±‚:** [$PR_URL]($PR_URL)" >> $GITHUB_STEP_SUMMARY
        echo "**åˆ†æ”¯:** \`$BRANCH_NAME\`" >> $GITHUB_STEP_SUMMARY
        echo "**ç›®æ ‡åˆ†æ”¯:** \`${{ inputs.base-branch }}\`" >> $GITHUB_STEP_SUMMARY
        
        # Add cleanup summary if cleanup was enabled
        if [ "${{ inputs.cleanup-branches }}" = "true" ]; then
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ğŸ§¹ åˆ†æ”¯æ¸…ç†æ‘˜è¦" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          CLEANUP_COUNT="${{ steps.cleanup-branches.outputs.cleanup-count }}"
          CLEANED_COUNT="${{ steps.cleanup-branches.outputs.cleaned-count }}"
          
          if [ "$CLEANUP_COUNT" = "0" ]; then
            echo "âœ¨ æœªæ‰¾åˆ°éœ€è¦æ¸…ç†çš„æ—§åˆ†æ”¯" >> $GITHUB_STEP_SUMMARY
          else
            if [ "${{ inputs.cleanup-dry-run }}" = "true" ]; then
              echo "ğŸ” **å¹²è¿è¡Œæ¨¡å¼:** æ‰¾åˆ° $CLEANUP_COUNT ä¸ªå°†è¢«æ¸…ç†çš„åˆ†æ”¯" >> $GITHUB_STEP_SUMMARY
            else
              echo "ğŸ—‘ï¸ **å·²æ¸…ç†:** $CLEANUP_COUNT ä¸ªè¯†åˆ«åˆ†æ”¯ä¸­çš„ $CLEANED_COUNT ä¸ª" >> $GITHUB_STEP_SUMMARY
            fi
            echo "**æ¨¡å¼:** \`${{ inputs.cleanup-pattern }}\`" >> $GITHUB_STEP_SUMMARY
            echo "**ä¿ç•™å¤©æ•°:** ${{ inputs.cleanup-keep-days }}" >> $GITHUB_STEP_SUMMARY
            echo "**ä»…å·²åˆå¹¶:** ${{ inputs.cleanup-merged-only }}" >> $GITHUB_STEP_SUMMARY
          fi
        fi

    - name: Cleanup-only summary
      if: inputs.cleanup-branches == 'true' && steps.commit-changes.outputs.branch-name == ''
      shell: bash
      run: |
        echo "## ğŸ§¹ åˆ†æ”¯æ¸…ç†æ‘˜è¦" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        CLEANUP_COUNT="${{ steps.cleanup-branches.outputs.cleanup-count }}"
        CLEANED_COUNT="${{ steps.cleanup-branches.outputs.cleaned-count }}"
        
        if [ "$CLEANUP_COUNT" = "0" ]; then
          echo "âœ¨ æœªæ‰¾åˆ°éœ€è¦æ¸…ç†çš„æ—§åˆ†æ”¯" >> $GITHUB_STEP_SUMMARY
        else
          if [ "${{ inputs.cleanup-dry-run }}" = "true" ]; then
            echo "ğŸ” **å¹²è¿è¡Œæ¨¡å¼:** æ‰¾åˆ° $CLEANUP_COUNT ä¸ªå°†è¢«æ¸…ç†çš„åˆ†æ”¯" >> $GITHUB_STEP_SUMMARY
          else
            echo "ğŸ—‘ï¸ **å·²æ¸…ç†:** $CLEANUP_COUNT ä¸ªè¯†åˆ«åˆ†æ”¯ä¸­çš„ $CLEANED_COUNT ä¸ª" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**é…ç½®ä¿¡æ¯:**" >> $GITHUB_STEP_SUMMARY
          echo "- **æ¨¡å¼:** \`${{ inputs.cleanup-pattern }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **ä¿ç•™å¤©æ•°:** ${{ inputs.cleanup-keep-days }}" >> $GITHUB_STEP_SUMMARY
          echo "- **ä»…å·²åˆå¹¶:** ${{ inputs.cleanup-merged-only }}" >> $GITHUB_STEP_SUMMARY
        fi
